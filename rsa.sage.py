
# This file was *autogenerated* from the file rsa.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_128 = Integer(128); _sage_const_8 = Integer(8); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)
from random import getrandbits, randint
from array import array
from sage.crypto.util import bin_to_ascii
from sage.crypto.util import ascii_to_bin

class RSA(object):
    def __init__(self, object=None):
        self.message = object

    def session_key(self):
        binary = ascii_to_bin(self.message)
        binary = str(binary)
        print binary
        if len(binary)%_sage_const_8 :
            q = _sage_const_8 -(len(binary)%_sage_const_8 )
            binary = (q+_sage_const_2 )*'0'+binary[_sage_const_2 :]
        m = int(binary,_sage_const_2 )
        return m

    @staticmethod
    def __test_Ferma(number=_sage_const_0 , rounds=_sage_const_128 ):
        if mod(number, _sage_const_2 ) == _sage_const_0 :
            return False
        for _ in range(rounds):
            a = (randint(_sage_const_2 , number-_sage_const_1 ))**(number-_sage_const_1 )
            if mod(a, number) != _sage_const_1 :
                return False
        return True

    @staticmethod
    def gen_primary_number(bits, p=_sage_const_0 ):
        p = getrandbits(bits)
        while not RSA.__test_Ferma(p):
            p = getrandbits(bits)
        return p

    @staticmethod
    def __ColculationPublicExponent(n, Fi):
        e = randint(_sage_const_2 , Fi-_sage_const_1 )
        while gcd(e, Fi) != _sage_const_1 :
            e = randint(_sage_const_2 , Fi-_sage_const_1 )
        return e

    @staticmethod
    def __ColculationSecretExponent(e, Fi):
        return mod(xgcd(e, Fi)[_sage_const_1 ], Fi)

    @staticmethod
    def encrypt(n,m,public_key):
        R = IntegerModRing(n)
        return R(m**public_key[_sage_const_0 ])

    @staticmethod
    def decrypt(n,encryption_message,private_key):
        R = IntegerModRing(n)
        tmp = R(encryption_message**private_key[_sage_const_0 ])
        binary = bin(tmp)
        q = _sage_const_8 -(len(binary)%_sage_const_8 )
        binary = (q+_sage_const_2 )*'0'+binary[_sage_const_2 :]
        print "binary: %s" % binary
        tmp = bin_to_ascii(binary)
        return tmp

    def run(self):
        m = self.session_key()
        print "m: %s" % m
        p = RSA.gen_primary_number(_sage_const_8 )
        q = RSA.gen_primary_number(_sage_const_8 )
        print "p: %s " % p
        print "q: %s" % q
        n = p*q
        Fi = euler_phi(n)
        e = RSA.__ColculationPublicExponent(n, Fi)
        d = RSA.__ColculationSecretExponent(e, Fi)
        if mod(e*d, Fi) != _sage_const_1 :
            print "Bad calculations :("
            return
        public_key = array('I', [e, n])
        private_key = array('I', [d, n])
        encryption_message = RSA.encrypt(n,m,public_key)
        print "enc: {}".format(encryption_message)
        decryption_message = RSA.decrypt(n,encryption_message,private_key)
        print "dec: {}".format(decryption_message)

def main():
    rsa = RSA("k")
    rsa.run()


if __name__ == "__main__":
    main()

