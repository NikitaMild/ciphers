
# This file was *autogenerated* from the file rsa.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_128 = Integer(128); _sage_const_8 = Integer(8)
from random import getrandbits, randint
from array import array


class RSA(object):
    def __init__(self, object=None):
        try:
            self.message = [ord(x) for x in object]
        except:
            self.message = object

    def session_key(self):
        m = ZZ(list(reversed(self.message)), _sage_const_100 )
        return m

    @staticmethod
    def __test_Ferma(number=_sage_const_0 , rounds=_sage_const_128 ):
        if mod(number, _sage_const_2 ) == _sage_const_0 :
            return False
        for _ in range(rounds):
            a = (randint(_sage_const_2 , number-_sage_const_1 ))**(number-_sage_const_1 )
            if mod(a, number) != _sage_const_1 :
                return False
        return True

    @staticmethod
    def gen_primary_number(bits, p=_sage_const_0 ):
        p = getrandbits(bits)
        while not RSA.__test_Ferma(p):
            p = getrandbits(bits)
        return p

    @staticmethod
    def __colculation_public_exponent(n, Fi):
        e = randint(_sage_const_2 , Fi-_sage_const_1 )
        while gcd(e, Fi) != _sage_const_1 :
            e = randint(_sage_const_2 , Fi-_sage_const_1 )
        return e

    @staticmethod
    def __colculation_secret_exponent(e, Fi):
        return mod(xgcd(e, Fi)[_sage_const_1 ], Fi)

    @staticmethod
    def encrypt(m,public_key):
        return (m**public_key[_sage_const_0 ]) % public_key[_sage_const_1 ]

    @staticmethod
    def decrypt(encryption_message,private_key):
        return (encryption_message**private_key[_sage_const_0 ])

    def run(self):
        m = self.session_key()
        print "m: %s" % m
        p = RSA.gen_primary_number(_sage_const_8 )
        q = RSA.gen_primary_number(_sage_const_8 )
        print "p: %s " % p
        print "q: %s" % q
        n = p*q
        Fi = euler_phi(n)
        e = RSA.__colculation_public_exponent(n, Fi)
        d = RSA.__colculation_secret_exponent(e, Fi)
        if mod(e*d, Fi) != _sage_const_1 :
            print "Bad calculations :("
            return
        public_key = array('I', [e, n])
        private_key = array('I', [d, n])
        encryption_message = RSA.encrypt(m,public_key)
        print "enc: {}".format(encryption_message)
        decryption_message = RSA.decrypt(encryption_message,private_key)
        print "dec: {}".format(decryption_message)

def main():
    #message = raw_input("please enter your message: ")
    rsa = RSA("loh")
    rsa.run()


if __name__ == "__main__":
    main()

